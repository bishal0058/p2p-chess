<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P SVG Chess</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --primary: #764ba2; --bg: #2d3436; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        /* Lobby / Connection UI */
        .lobby-panel {
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            width: 100%;
            max-width: 400px;
            margin-bottom: 20px;
        }

        .id-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            background: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
            margin: 15px 0;
        }

        #my-id {
            font-weight: bold;
            color: var(--primary);
            user-select: none; /* Make this not manually copyable */
        }

        .copy-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
        }

        input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        button.main-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            width: 100%;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
        }

        /* Game Board UI */
        #game-area { display: none; flex-direction: column; align-items: center; }

        .game-info {
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 20px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        #chessboard {
            border: 5px solid #555;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            background-color: #b58863;
        }

        /* Squares */
        .light { fill: #f0d9b5; }
        .dark { fill: #b58863; }
        .selected { fill: rgba(255, 255, 0, 0.6) !important; }
        .possible { fill: rgba(0, 255, 0, 0.4) !important; }

        /* Piece Text */
        .piece { cursor: pointer; user-select: none; }
        
        /* Flip logic */
        .flipped { transform: rotate(180deg); }
        .flipped text { transform: rotate(180deg); transform-origin: center; transform-box: fill-box; }

        #promotionModal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100; justify-content: center; align-items: center;
        }
        .promo-box { background: white; padding: 20px; border-radius: 10px; display: flex; gap: 15px; }
        .promo-choice { font-size: 50px; cursor: pointer; border: 1px solid #ccc; border-radius: 5px; }
    </style>
</head>
<body>

    <div class="lobby-panel" id="lobby">
        <h2>Chess Lobby</h2>
        <p style="font-size: 0.9em; color: #666;">Share your ID with a friend</p>
        
        <div class="id-container">
            <span id="my-id">Generating ID...</span>
            <button class="copy-btn" onclick="game.copyID()">Copy</button>
        </div>

        <input type="text" id="peer-id-input" placeholder="Enter friend's ID">
        <button class="main-btn" onclick="game.connectToPeer()">Connect & Play</button>
        <p id="conn-status" style="margin-top: 10px; font-weight: bold; color: var(--primary);"></p>
    </div>

    <div id="game-area">
        <div class="game-info">
            <span id="turn-text">White's Turn</span> | 
            <span id="player-color-text"></span>
        </div>
        
        <svg id="chessboard" width="480" height="480" viewBox="0 0 480 480">
            <g id="squares-layer"></g>
            <g id="pieces-layer"></g>
        </svg>

        <div style="margin-top: 20px;">
            <button onclick="location.reload()" style="padding: 5px 15px; cursor: pointer;">Quit Game</button>
        </div>
    </div>

    <div id="promotionModal">
        <div class="promo-box" id="promo-options"></div>
    </div>

    <script>
        const SYMBOLS = {
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
            'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
        };

        class ChessGame {
            constructor() {
                this.board = this.initBoard();
                this.turn = 'white';
                this.myColor = null; 
                this.selected = null;
                this.moves = [];
                
                this.peer = new Peer();
                this.conn = null;

                this.setupPeer();
                this.createBoardSVG();
            }

            initBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    ...Array(4).fill().map(() => Array(8).fill(null)),
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            setupPeer() {
                this.peer.on('open', id => document.getElementById('my-id').innerText = id);
                
                // When someone connects to us
                this.peer.on('connection', c => {
                    this.conn = c;
                    this.myColor = 'black';
                    this.startGame();
                });
            }

            connectToPeer() {
                const id = document.getElementById('peer-id-input').value;
                if (!id) return;
                this.conn = this.peer.connect(id);
                this.myColor = 'white';
                this.conn.on('open', () => this.startGame());
            }

            copyID() {
                const id = document.getElementById('my-id').innerText;
                navigator.clipboard.writeText(id);
                const btn = document.querySelector('.copy-btn');
                btn.innerText = "Copied!";
                setTimeout(() => btn.innerText = "Copy", 2000);
            }

            startGame() {
                document.getElementById('lobby').style.display = 'none';
                document.getElementById('game-area').style.display = 'flex';
                document.getElementById('player-color-text').innerText = "You are " + this.myColor.toUpperCase();
                
                if (this.myColor === 'black') {
                    document.getElementById('chessboard').classList.add('flipped');
                }

                this.conn.on('data', data => {
                    if (data.type === 'move') this.executeMove(data.from, data.to, data.promo);
                });

                this.render();
            }

            createBoardSVG() {
                const layer = document.getElementById('squares-layer');
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', c * 60); rect.setAttribute('y', r * 60);
                        rect.setAttribute('width', 60); rect.setAttribute('height', 60);
                        rect.setAttribute('class', `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`);
                        rect.dataset.r = r; rect.dataset.c = c;
                        rect.onclick = () => this.handleSquareClick(r, c);
                        layer.appendChild(rect);
                    }
                }
            }

            handleSquareClick(r, c) {
                if (this.turn !== this.myColor) return;

                const piece = this.board[r][c];
                const isOwnPiece = piece && (this.turn === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase());

                if (isOwnPiece) {
                    this.selected = {r, c};
                    this.moves = this.getLegalMoves(r, c);
                } else if (this.selected) {
                    const targetMove = this.moves.find(m => m.r === r && m.c === c);
                    if (targetMove) {
                        this.handleMoveAttempt(this.selected, {r, c});
                    } else {
                        this.selected = null;
                        this.moves = [];
                    }
                }
                this.render();
            }

            handleMoveAttempt(from, to) {
                const piece = this.board[from.r][from.c];
                // Pawn Promotion check
                if (piece.toLowerCase() === 'p' && (to.r === 0 || to.r === 7)) {
                    this.showPromotion(from, to);
                } else {
                    this.executeMove(from, to);
                    this.conn.send({ type: 'move', from, to });
                }
            }

            executeMove(from, to, promo = null) {
                let piece = this.board[from.r][from.c];
                if (promo) piece = this.turn === 'white' ? promo.toUpperCase() : promo.toLowerCase();
                
                this.board[to.r][to.c] = piece;
                this.board[from.r][from.c] = null;
                this.turn = (this.turn === 'white') ? 'black' : 'white';
                this.selected = null;
                this.moves = [];
                this.render();
            }

            getLegalMoves(r, c) {
                const piece = this.board[r][c];
                const color = piece === piece.toUpperCase() ? 'white' : 'black';
                const moves = [];

                // Simple logic for move generation (Full Chess logic)
                // This is a condensed version of the legal move checker
                for (let tr = 0; tr < 8; tr++) {
                    for (let tc = 0; tc < 8; tc++) {
                        if (this.isPseudoLegal(r, c, tr, tc)) {
                            // Check if move puts own king in check
                            if (!this.wouldBeInCheck(r, c, tr, tc)) {
                                moves.push({r: tr, c: tc});
                            }
                        }
                    }
                }
                return moves;
            }

            isPseudoLegal(r, c, tr, tc) {
                const p = this.board[r][c];
                const target = this.board[tr][tc];
                if (target && (p === p.toUpperCase()) === (target === target.toUpperCase())) return false;
                
                const type = p.toLowerCase();
                const dr = tr - r;
                const dc = tc - c;
                const absDr = Math.abs(dr);
                const absDc = Math.abs(dc);

                if (type === 'p') {
                    const dir = (p === 'P') ? -1 : 1;
                    if (dc === 0 && target === null) { // Forward
                        if (dr === dir) return true;
                        if (dr === 2 * dir && (r === 1 || r === 6) && this.board[r + dir][c] === null) return true;
                    }
                    if (absDc === 1 && dr === dir && target !== null) return true; // Capture
                    return false;
                }
                if (type === 'n') return (absDr === 2 && absDc === 1) || (absDr === 1 && absDc === 2);
                if (type === 'k') return absDr <= 1 && absDc <= 1;
                if (type === 'r' || type === 'q' || type === 'b') {
                    const isStraight = (dr === 0 || dc === 0);
                    const isDiag = (absDr === absDc);
                    if (type === 'r' && !isStraight) return false;
                    if (type === 'b' && !isDiag) return false;
                    if (type === 'q' && !isStraight && !isDiag) return false;
                    
                    // Obstacle check
                    const stepR = dr === 0 ? 0 : dr / absDr;
                    const stepC = dc === 0 ? 0 : dc / absDc;
                    let currR = r + stepR, currC = c + stepC;
                    while (currR !== tr || currC !== tc) {
                        if (this.board[currR][currC] !== null) return false;
                        currR += stepR; currC += stepC;
                    }
                    return true;
                }
                return false;
            }

            wouldBeInCheck(fr, fc, tr, tc) {
                const color = (this.board[fr][fc] === this.board[fr][fc].toUpperCase()) ? 'white' : 'black';
                const originalTarget = this.board[tr][tc];
                const originalPiece = this.board[fr][fc];
                
                // Simulate
                this.board[tr][tc] = originalPiece;
                this.board[fr][fc] = null;
                
                let inCheck = false;
                // Find king
                let kr, kc;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.board[r][c] === (color === 'white' ? 'K' : 'k')) { kr = r; kc = c; }
                    }
                }
                // Check if any opponent piece can hit this king
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = this.board[r][c];
                        if (p && (p === p.toUpperCase() ? 'white' : 'black') !== color) {
                            if (this.isPseudoLegal(r, c, kr, kc)) { inCheck = true; break; }
                        }
                    }
                }
                // Revert
                this.board[fr][fc] = originalPiece;
                this.board[tr][tc] = originalTarget;
                return inCheck;
            }

            showPromotion(from, to) {
                const modal = document.getElementById('promotionModal');
                const box = document.getElementById('promo-options');
                box.innerHTML = '';
                ['q', 'r', 'b', 'n'].forEach(type => {
                    const btn = document.createElement('div');
                    btn.className = 'promo-choice';
                    btn.innerText = SYMBOLS[this.turn === 'white' ? type.toUpperCase() : type];
                    btn.onclick = () => {
                        modal.style.display = 'none';
                        this.executeMove(from, to, type);
                        this.conn.send({ type: 'move', from, to, promo: type });
                    };
                    box.appendChild(btn);
                });
                modal.style.display = 'flex';
            }

            render() {
                const pLayer = document.getElementById('pieces-layer');
                pLayer.innerHTML = '';
                
                // Reset square highlights
                document.querySelectorAll('.square').forEach(s => s.classList.remove('selected', 'possible'));

                if (this.selected) {
                    const selSq = document.querySelector(`rect[data-r="${this.selected.r}"][data-c="${this.selected.c}"]`);
                    selSq.classList.add('selected');
                    this.moves.forEach(m => {
                        document.querySelector(`rect[data-r="${m.r}"][data-c="${m.c}"]`).classList.add('possible');
                    });
                }

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = this.board[r][c];
                        if (p) {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', c * 60 + 30);
                            text.setAttribute('y', r * 60 + 48);
                            text.setAttribute('text-anchor', 'middle');
                            text.setAttribute('font-size', '50');
                            text.setAttribute('class', 'piece');
                            text.textContent = SYMBOLS[p];
                            text.onclick = () => this.handleSquareClick(r, c);
                            pLayer.appendChild(text);
                        }
                    }
                }
                document.getElementById('turn-text').innerText = this.turn.toUpperCase() + "'s Turn";
            }
        }

        const game = new ChessGame();
    </script>
</body>
</html>
