<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P SVG Chess Game</title>
    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* Your existing styles... */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        /* NEW: Connection UI Styles */
        .p2p-panel {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .id-badge { background: #eee; padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer; }
        input { padding: 8px; border: 1px solid #ccc; border-radius: 5px; }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }

        h1 { text-align: center; color: #333; margin-bottom: 20px; font-size: 2.5em; }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 10px;
        }

        .turn-indicator { font-size: 1.2em; font-weight: bold; padding: 10px 20px; border-radius: 25px; }
        .white-turn { background: white; color: #333; }
        .black-turn { background: #333; color: white; }

        .captured-pieces { display: flex; gap: 5px; flex-wrap: wrap; min-height: 40px; }
        .captured-piece { width: 30px; height: 30px; opacity: 0.7; }

        .board-container { display: flex; justify-content: center; margin: 20px 0; position: relative; }
        #chessboard { cursor: pointer; filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.2)); }

        .square.light { fill: #f0d9b5; }
        .square.dark { fill: #b58863; }
        .square.highlight { fill: #f6f669 !important; opacity: 0.7; }
        .square.possible-move { fill: #7fbf7f !important; opacity: 0.5; }
        .square.selected { fill: #ff6b6b !important; opacity: 0.7; }

        .piece { cursor: grab; transition: transform 0.2s ease; pointer-events: all; }
        .piece.dragging { cursor: grabbing; opacity: 0.8; }

        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
        button {
            padding: 10px 20px; font-weight: bold; border: none; border-radius: 25px;
            cursor: pointer; background: #764ba2; color: white;
        }

        .game-status { text-align: center; margin-top: 20px; padding: 15px; border-radius: 10px; font-weight: bold; }
        .status-checkmate { background: #f8d7da; color: #721c24; border: 2px solid #dc3545; }

        .promotion-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); z-index: 1000; justify-content: center; align-items: center;
        }
        .promotion-content { background: white; padding: 30px; border-radius: 15px; text-align: center; }
        .promotion-pieces { display: flex; gap: 20px; margin-top: 20px; }
        .promotion-piece { cursor: pointer; padding: 10px; border-radius: 10px; }
    </style>
</head>
<body>

    <!-- NEW: Connection Panel -->
    <div class="p2p-panel">
        <div>Your ID: <span id="my-id" class="id-badge">...loading...</span></div>
        <input type="text" id="peer-id-input" placeholder="Paste Friend's ID">
        <button onclick="game.connectToPeer()">Connect to Friend</button>
        <div id="connection-status" style="color: #764ba2; font-weight: bold;">(Not Connected)</div>
    </div>

    <div class="game-container">
        <h1>♔ P2P Chess Game ♚</h1>
        
        <div class="game-info">
            <div class="turn-indicator white-turn" id="turnIndicator">White's Turn</div>
            <div>
                <div>White Captured:</div>
                <div class="captured-pieces" id="whiteCaptured"></div>
            </div>
            <div>
                <div>Black Captured:</div>
                <div class="captured-pieces" id="blackCaptured"></div>
            </div>
        </div>

        <div class="board-container">
            <svg id="chessboard" width="480" height="480" viewBox="0 0 480 480">
                <g id="squares"></g>
                <g id="pieces"></g>
            </svg>
        </div>

        <div class="controls">
            <button onclick="game.reset()">New Game</button>
            <button onclick="game.flipBoard()">Flip Board</button>
        </div>

        <div id="gameStatus" class="game-status" style="display: none;"></div>
    </div>

    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-content">
            <h2>Choose Promotion Piece</h2>
            <div class="promotion-pieces" id="promotionPieces"></div>
        </div>
    </div>

    <script>
        class ChessGame {
            constructor() {
                this.board = this.initializeBoard();
                this.currentTurn = 'white';
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.capturedPieces = { white: [], black: [] };
                this.moveHistory = [];
                this.boardFlipped = false;
                
                // P2P Setup
                this.peer = new Peer();
                this.conn = null;
                this.myColor = null; // 'white' or 'black'

                this.setupPeerEvents();
                this.initializeSVG();
                this.renderBoard();
                this.renderPieces();
                this.attachEventListeners();
            }

            // --- P2P LOGIC ---
            setupPeerEvents() {
                this.peer.on('open', (id) => {
                    document.getElementById('my-id').innerText = id;
                });

                // When someone connects to YOU
                this.peer.on('connection', (connection) => {
                    this.conn = connection;
                    this.myColor = 'black'; // Recipient is black
                    document.getElementById('connection-status').innerText = "Playing as BLACK";
                    this.setupDataListener();
                });
            }

            connectToPeer() {
                const peerId = document.getElementById('peer-id-input').value;
                if (!peerId) return alert("Enter an ID");
                
                this.conn = this.peer.connect(peerId);
                this.myColor = 'white'; // Initiator is white
                document.getElementById('connection-status').innerText = "Playing as WHITE";
                this.setupDataListener();
            }

            setupDataListener() {
                this.conn.on('data', (data) => {
                    if (data.type === 'move') {
                        // Directly execute the move received from the other player
                        this.executeMoveLogic(data.from.row, data.from.col, data.to.row, data.to.col, false);
                    }
                });
            }
            // -----------------

            initializeBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            initializeSVG() {
                const squaresGroup = document.getElementById('squares');
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        square.setAttribute('x', col * 60);
                        square.setAttribute('y', row * 60);
                        square.setAttribute('width', 60);
                        square.setAttribute('height', 60);
                        square.setAttribute('class', `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`);
                        square.setAttribute('data-row', row);
                        square.setAttribute('data-col', col);
                        squaresGroup.appendChild(square);
                    }
                }
            }

            renderBoard() {
                document.querySelectorAll('.square').forEach(sq => sq.classList.remove('highlight', 'possible-move', 'selected'));
                if (this.selectedSquare) {
                    const sel = document.querySelector(`[data-row="${this.selectedSquare.row}"][data-col="${this.selectedSquare.col}"]`);
                    if (sel) sel.classList.add('selected');
                    this.possibleMoves.forEach(m => {
                        const moveEl = document.querySelector(`[data-row="${m.row}"][data-col="${m.col}"]`);
                        if (moveEl) moveEl.classList.add('possible-move');
                    });
                }
            }

            renderPieces() {
                const piecesGroup = document.getElementById('pieces');
                piecesGroup.innerHTML = '';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) piecesGroup.appendChild(this.createPieceSVG(piece, col * 60, row * 60));
                    }
                }
            }

            createPieceSVG(piece, x, y) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'piece');
                g.setAttribute('data-piece', piece);
                g.setAttribute('data-x', x);
                g.setAttribute('data-y', y);
                g.setAttribute('transform', `translate(${x + 30}, ${y + 30})`);
                const color = piece === piece.toUpperCase() ? 'white' : 'black';
                const pType = piece.toLowerCase();
                
                // Simplified labels for SVG pieces
                const symbols = { 'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚' };
                g.innerHTML = `
                    <circle cx="0" cy="0" r="25" fill="${color === 'white' ? '#fff' : '#333'}" stroke="#999" stroke-width="2"/>
                    <text x="0" y="10" text-anchor="middle" font-size="30" fill="${color === 'white' ? '#000' : '#fff'}">${symbols[pType]}</text>
                `;
                return g;
            }

            attachEventListeners() {
                const svg = document.getElementById('chessboard');
                svg.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                svg.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                svg.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            }

            handleMouseDown(e) {
                // Prevent moving if not your turn or not connected
                if (this.conn && this.currentTurn !== this.myColor) return;

                const target = e.target.closest('.piece');
                if (!target) return;
                const x = parseInt(target.getAttribute('data-x')), y = parseInt(target.getAttribute('data-y'));
                const col = Math.floor(x/60), row = Math.floor(y/60);
                
                if (this.isCorrectTurn(this.board[row][col])) {
                    this.isDragging = true;
                    this.dragPiece = target;
                    this.dragOffset = { x: e.clientX - x - 30, y: e.clientY - y - 30 };
                    target.classList.add('dragging');
                    this.selectPiece(row, col);
                }
            }

            handleMouseMove(e) {
                if (!this.isDragging) return;
                const svg = document.getElementById('chessboard');
                const rect = svg.getBoundingClientRect();
                const x = e.clientX - rect.left - this.dragOffset.x;
                const y = e.clientY - rect.top - this.dragOffset.y;
                this.dragPiece.style.transform = `translate(${x}px, ${y}px)`;
            }

            handleMouseUp(e) {
                if (!this.isDragging) return;
                const svg = document.getElementById('chessboard');
                const rect = svg.getBoundingClientRect();
                const col = Math.floor((e.clientX - rect.left) / 60);
                const row = Math.floor((e.clientY - rect.top) / 60);

                if (this.isInBounds(row, col)) {
                    this.makeMove(row, col);
                }

                this.dragPiece.classList.remove('dragging');
                this.dragPiece.style.transform = '';
                this.isDragging = false;
            }

            isCorrectTurn(piece) {
                if (!piece) return false;
                const color = piece === piece.toUpperCase() ? 'white' : 'black';
                return this.currentTurn === color;
            }

            selectPiece(row, col) {
                this.selectedSquare = { row, col };
                this.possibleMoves = this.getPossibleMoves(row, col);
                this.renderBoard();
            }

            // Logic shared by both Local Move and Received P2P move
            executeMoveLogic(fromRow, fromCol, toRow, toCol, isLocal) {
                const capturedPiece = this.board[toRow][toCol];
                if (capturedPiece) {
                    const color = capturedPiece === capturedPiece.toUpperCase() ? 'white' : 'black';
                    this.capturedPieces[color].push(capturedPiece);
                    this.updateCapturedPieces();
                }

                this.board[toRow][toCol] = this.board[fromRow][fromCol];
                this.board[fromRow][fromCol] = null;

                // Sync to Peer if this was a local move
                if (isLocal && this.conn) {
                    this.conn.send({
                        type: 'move',
                        from: { row: fromRow, col: fromCol },
                        to: { row: toRow, col: toCol }
                    });
                }

                this.finishTurn();
            }

            makeMove(toRow, toCol) {
                if (!this.selectedSquare) return;
                const { row: fR, col: fC } = this.selectedSquare;
                
                const valid = this.possibleMoves.some(m => m.row === toRow && m.col === toCol);
                if (!valid) return this.clearSelection();

                this.executeMoveLogic(fR, fC, toRow, toCol, true);
            }

            getPossibleMoves(row, col) {
                // Simplified: allows any movement for now as per your original logic 
                // but restricts destination to not being your own piece
                const moves = [];
                const piece = this.board[row][col];
                for(let r=0; r<8; r++){
                    for(let c=0; c<8; c++){
                        const target = this.board[r][c];
                        if (!target || this.isOpponent(piece, target)) {
                            moves.push({row: r, col: c});
                        }
                    }
                }
                return moves;
            }

            isOpponent(p1, p2) {
                if (!p1 || !p2) return true;
                return (p1 === p1.toUpperCase()) !== (p2 === p2.toUpperCase());
            }

            finishTurn() {
                this.clearSelection();
                this.currentTurn = this.currentTurn === 'white' ? 'black' : 'white';
                this.updateTurnIndicator();
                this.renderPieces();
                this.checkGameStatus();
            }

            clearSelection() {
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.renderBoard();
            }

            updateTurnIndicator() {
                const ind = document.getElementById('turnIndicator');
                ind.textContent = `${this.currentTurn.toUpperCase()}'s Turn`;
                ind.className = `turn-indicator ${this.currentTurn}-turn`;
            }

            updateCapturedPieces() {
                ['white', 'black'].forEach(c => {
                    const container = document.getElementById(`${c}Captured`);
                    container.innerHTML = '';
                    this.capturedPieces[c].forEach(p => {
                        const svg = this.createPieceSVG(p, 0, 0);
                        svg.classList.add('captured-piece');
                        container.appendChild(svg);
                    });
                });
            }

            checkGameStatus() {
                // Check if Kings exist
                let kings = { white: false, black: false };
                this.board.flat().forEach(p => {
                    if (p === 'K') kings.white = true;
                    if (p === 'k') kings.black = true;
                });
                if (!kings.white || !kings.black) {
                    const status = document.getElementById('gameStatus');
                    status.textContent = `CHECKMATE! ${kings.white ? 'White' : 'Black'} Wins!`;
                    status.style.display = 'block';
                    status.className = 'game-status status-checkmate';
                }
            }

            isInBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

            reset() { location.reload(); }

            flipBoard() {
                this.boardFlipped = !this.boardFlipped;
                document.getElementById('chessboard').style.transform = this.boardFlipped ? 'rotate(180deg)' : 'rotate(0deg)';
            }
        }

        const game = new ChessGame();
    </script>
</body>
</html>
