<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P SVG Chess Game</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .p2p-panel {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: center;
        }
        .id-badge { background: #eee; padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer; }
        input { padding: 8px; border: 1px solid #ccc; border-radius: 5px; }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
        }

        h1 { text-align: center; color: #333; margin-bottom: 20px; font-size: 1.5em; }

        .game-info {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding: 10px; background: #f0f0f0; border-radius: 10px;
        }

        .turn-indicator { font-size: 1em; font-weight: bold; padding: 5px 15px; border-radius: 15px; }
        .white-turn { background: white; color: #333; border: 1px solid #ccc; }
        .black-turn { background: #333; color: white; }

        .board-container { display: flex; justify-content: center; position: relative; }
        #chessboard { cursor: pointer; border: 5px solid #333; }

        .square.light { fill: #f0d9b5; }
        .square.dark { fill: #b58863; }
        .square.possible-move { fill: rgba(0, 255, 0, 0.3) !important; }
        .square.selected { fill: rgba(255, 255, 0, 0.5) !important; }
        .square.in-check { fill: rgba(255, 0, 0, 0.5) !important; }

        .piece { cursor: grab; transition: transform 0.1s ease; }
        .piece.dragging { cursor: grabbing; opacity: 0.8; pointer-events: none; }

        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
        button {
            padding: 10px 20px; font-weight: bold; border: none; border-radius: 25px;
            cursor: pointer; background: #764ba2; color: white;
        }

        #promotionModal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); z-index: 1000; justify-content: center; align-items: center;
        }
        .promotion-content { background: white; padding: 20px; border-radius: 10px; display: flex; gap: 10px; }
        .promo-btn { font-size: 40px; cursor: pointer; border: 1px solid #ccc; padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>

    <div class="p2p-panel">
        <div>Your ID: <span id="my-id" class="id-badge" onclick="navigator.clipboard.writeText(this.innerText)">...loading...</span></div>
        <input type="text" id="peer-id-input" placeholder="Paste Friend's ID">
        <button onclick="game.connectToPeer()">Connect to Friend</button>
        <div id="connection-status">(Local Play)</div>
    </div>

    <div class="game-container">
        <h1 id="statusText">♔ SVG P2P Chess ♚</h1>
        <div class="game-info">
            <div class="turn-indicator white-turn" id="turnIndicator">White's Turn</div>
        </div>
        <div class="board-container">
            <svg id="chessboard" width="480" height="480" viewBox="0 0 480 480">
                <g id="squares"></g>
                <g id="pieces"></g>
            </svg>
        </div>
        <div class="controls">
            <button onclick="location.reload()">New Game</button>
            <button onclick="game.flipBoard()">Flip Board</button>
        </div>
    </div>

    <div id="promotionModal">
        <div class="promotion-content" id="promotionOptions"></div>
    </div>

    <script>
        const SYMBOLS = {
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
            'P': '♙', 'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔'
        };

        class ChessGame {
            constructor() {
                this.board = this.initializeBoard();
                this.currentTurn = 'white';
                this.selectedSquare = null;
                this.legalMoves = [];
                this.isDragging = false;
                this.dragPiece = null;
                this.myColor = null; 
                this.isFlipped = false;

                this.peer = new Peer();
                this.conn = null;

                this.setupPeer();
                this.initSVG();
                this.render();
                this.attachEvents();
            }

            initializeBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    Array(8).fill(null), Array(8).fill(null), Array(8).fill(null), Array(8).fill(null),
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            setupPeer() {
                this.peer.on('open', id => document.getElementById('my-id').innerText = id);
                this.peer.on('connection', c => {
                    this.conn = c;
                    this.myColor = 'black';
                    document.getElementById('connection-status').innerText = "Playing as BLACK";
                    this.setupDataListener();
                });
            }

            connectToPeer() {
                const id = document.getElementById('peer-id-input').value;
                if (!id) return;
                this.conn = this.peer.connect(id);
                this.myColor = 'white';
                document.getElementById('connection-status').innerText = "Playing as WHITE";
                this.setupDataListener();
            }

            setupDataListener() {
                this.conn.on('data', data => {
                    if (data.type === 'move') {
                        this.executeMove(data.from, data.to, data.promotion);
                    }
                });
            }

            initSVG() {
                const group = document.getElementById('squares');
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', c * 60); rect.setAttribute('y', r * 60);
                        rect.setAttribute('width', 60); rect.setAttribute('height', 60);
                        rect.setAttribute('class', `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`);
                        rect.dataset.row = r; rect.dataset.col = c;
                        group.appendChild(rect);
                    }
                }
            }

            render() {
                const pGroup = document.getElementById('pieces');
                pGroup.innerHTML = '';
                
                // Clear highlights
                document.querySelectorAll('.square').forEach(s => 
                    s.classList.remove('selected', 'possible-move', 'in-check'));

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece) {
                            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                            g.setAttribute('class', 'piece');
                            g.dataset.row = r; g.dataset.col = c;
                            g.innerHTML = `<text x="${c * 60 + 30}" y="${r * 60 + 45}" font-size="45" text-anchor="middle" fill="${piece === piece.toUpperCase() ? '#000' : '#000'}">${SYMBOLS[piece]}</text>`;
                            pGroup.appendChild(g);
                        }
                    }
                }

                if (this.selectedSquare) {
                    this.getSquareEl(this.selectedSquare.r, this.selectedSquare.c).classList.add('selected');
                    this.legalMoves.forEach(m => this.getSquareEl(m.r, m.c).classList.add('possible-move'));
                }
            }

            getSquareEl(r, c) { return document.querySelector(`rect[data-row="${r}"][data-col="${c}"]`); }

            attachEvents() {
                const svg = document.getElementById('chessboard');
                svg.addEventListener('mousedown', e => {
                    if (this.myColor && this.currentTurn !== this.myColor) return;
                    const coords = this.getCoords(e);
                    const piece = this.board[coords.r][coords.c];
                    if (piece && this.getPieceColor(piece) === this.currentTurn) {
                        this.selectedSquare = coords;
                        this.legalMoves = this.getLegalMoves(coords.r, coords.c, this.board);
                        this.render();
                    }
                });

                svg.addEventListener('mouseup', e => {
                    if (!this.selectedSquare) return;
                    const target = this.getCoords(e);
                    const move = this.legalMoves.find(m => m.r === target.r && m.c === target.c);
                    
                    if (move) {
                        this.handleMoveAttempt(this.selectedSquare, target);
                    } else {
                        this.selectedSquare = null;
                        this.legalMoves = [];
                        this.render();
                    }
                });
            }

            getCoords(e) {
                const rect = document.getElementById('chessboard').getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                return { r: Math.floor(y / 60), c: Math.floor(x / 60) };
            }

            getPieceColor(p) { return p === p.toUpperCase() ? 'white' : 'black'; }

            getLegalMoves(r, c, board) {
                const piece = board[r][c];
                const rawMoves = this.getRawMoves(r, c, board);
                // Filter moves: Can't move into check
                return rawMoves.filter(m => !this.wouldBeInCheck(r, c, m.r, m.c));
            }

            getRawMoves(r, c, board) {
                const piece = board[r][c];
                const type = piece.toLowerCase();
                const color = this.getPieceColor(piece);
                const moves = [];

                if (type === 'p') {
                    const dir = color === 'white' ? -1 : 1;
                    const startRank = color === 'white' ? 6 : 1;
                    // Forward
                    if (this.isEmpty(r + dir, c, board)) {
                        moves.push({r: r + dir, c});
                        if (r === startRank && this.isEmpty(r + 2 * dir, c, board)) moves.push({r: r + 2 * dir, c});
                    }
                    // Captures
                    [[dir, 1], [dir, -1]].forEach(([dr, dc]) => {
                        const nr = r + dr, nc = c + dc;
                        if (this.onBoard(nr, nc) && !this.isEmpty(nr, nc, board) && this.getPieceColor(board[nr][nc]) !== color) {
                            moves.push({r: nr, c: nc});
                        }
                    });
                } else if (type === 'n') {
                    [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]].forEach(([dr, dc]) => {
                        const nr = r + dr, nc = c + dc;
                        if (this.onBoard(nr, nc) && (this.isEmpty(nr, nc, board) || this.getPieceColor(board[nr][nc]) !== color)) {
                            moves.push({r: nr, c: nc});
                        }
                    });
                } else if (['r', 'b', 'q'].includes(type)) {
                    const dirs = type === 'r' ? [[0,1],[0,-1],[1,0],[-1,0]] : 
                                 type === 'b' ? [[1,1],[1,-1],[-1,1],[-1,-1]] : 
                                 [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
                    dirs.forEach(([dr, dc]) => {
                        let nr = r + dr, nc = c + dc;
                        while (this.onBoard(nr, nc)) {
                            if (this.isEmpty(nr, nc, board)) moves.push({r: nr, c: nc});
                            else {
                                if (this.getPieceColor(board[nr][nc]) !== color) moves.push({r: nr, c: nc});
                                break;
                            }
                            nr += dr; nc += dc;
                        }
                    });
                } else if (type === 'k') {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = r + dr, nc = c + dc;
                            if (this.onBoard(nr, nc) && (this.isEmpty(nr, nc, board) || this.getPieceColor(board[nr][nc]) !== color)) {
                                moves.push({r: nr, c: nc});
                            }
                        }
                    }
                }
                return moves;
            }

            wouldBeInCheck(fr, fc, tr, tc) {
                const color = this.getPieceColor(this.board[fr][fc]);
                const tempBoard = this.board.map(row => [...row]);
                tempBoard[tr][tc] = tempBoard[fr][fc];
                tempBoard[fr][fc] = null;

                // Find King
                let kr, kc;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (tempBoard[r][c] === (color === 'white' ? 'K' : 'k')) {
                            kr = r; kc = c;
                        }
                    }
                }
                // Is King attacked?
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = tempBoard[r][c];
                        if (p && this.getPieceColor(p) !== color) {
                            const attacks = this.getRawMoves(r, c, tempBoard);
                            if (attacks.some(m => m.r === kr && m.c === kc)) return true;
                        }
                    }
                }
                return false;
            }

            handleMoveAttempt(from, to) {
                const piece = this.board[from.r][from.c];
                // Pawn Promotion?
                if (piece.toLowerCase() === 'p' && (to.r === 0 || to.r === 7)) {
                    this.showPromotion(from, to);
                } else {
                    this.executeMove(from, to);
                    if (this.conn) this.conn.send({ type: 'move', from, to });
                }
            }

            executeMove(from, to, promo = null) {
                let piece = this.board[from.r][from.c];
                if (promo) piece = this.currentTurn === 'white' ? promo.toUpperCase() : promo.toLowerCase();
                
                this.board[to.r][to.c] = piece;
                this.board[from.r][from.c] = null;
                
                this.currentTurn = this.currentTurn === 'white' ? 'black' : 'white';
                this.selectedSquare = null;
                this.legalMoves = [];
                this.updateUI();
                this.render();
            }

            showPromotion(from, to) {
                const modal = document.getElementById('promotionModal');
                const container = document.getElementById('promotionOptions');
                container.innerHTML = '';
                const options = ['q', 'r', 'b', 'n'];
                options.forEach(o => {
                    const btn = document.createElement('div');
                    btn.className = 'promo-btn';
                    btn.innerText = SYMBOLS[this.currentTurn === 'white' ? o.toUpperCase() : o];
                    btn.onclick = () => {
                        modal.style.display = 'none';
                        this.executeMove(from, to, o);
                        if (this.conn) this.conn.send({ type: 'move', from, to, promotion: o });
                    };
                    container.appendChild(btn);
                });
                modal.style.display = 'flex';
            }

            updateUI() {
                const ind = document.getElementById('turnIndicator');
                ind.innerText = `${this.currentTurn.charAt(0).toUpperCase() + this.currentTurn.slice(1)}'s Turn`;
                ind.className = `turn-indicator ${this.currentTurn}-turn`;
            }

            isEmpty(r, c, board) { return board[r][c] === null; }
            onBoard(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

            flipBoard() {
                this.isFlipped = !this.isFlipped;
                document.getElementById('chessboard').style.transform = this.isFlipped ? 'rotate(180deg)' : '';
                document.querySelectorAll('.piece text').forEach(t => t.style.transform = this.isFlipped ? 'rotate(180deg)' : '');
                // Correct text orientation is tricky with SVG rotate, but CSS transform on board is easiest.
            }
        }

        const game = new ChessGame();
    </script>
</body>
</html>
