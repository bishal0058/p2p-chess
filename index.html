<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P SVG Chess Game</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .p2p-panel {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .id-badge { background: #eee; padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer; }
        .id-badge:hover { background: #ddd; }
        input { padding: 8px; border: 1px solid #ccc; border-radius: 5px; }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }

        h1 { text-align: center; color: #333; margin-bottom: 20px; font-size: 2.5em; }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 10px;
            gap: 15px;
            flex-wrap: wrap;
        }

        .turn-indicator { 
            font-size: 1.2em; 
            font-weight: bold; 
            padding: 10px 20px; 
            border-radius: 25px;
            transition: all 0.3s ease;
        }
        .white-turn { background: white; color: #333; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .black-turn { background: #333; color: white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); }

        .captured-section { min-width: 150px; }
        .captured-pieces { display: flex; gap: 5px; flex-wrap: wrap; min-height: 40px; }
        .captured-piece { width: 30px; height: 30px; opacity: 0.7; }

        .board-container { display: flex; justify-content: center; margin: 20px 0; position: relative; }
        #chessboard { 
            cursor: pointer; 
            filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.2));
            transition: transform 0.5s ease;
        }

        .square.light { fill: #f0d9b5; }
        .square.dark { fill: #b58863; }
        .square.highlight { fill: #f6f669 !important; opacity: 0.7; }
        .square.possible-move { fill: #7fbf7f !important; opacity: 0.5; }
        .square.selected { fill: #ff6b6b !important; opacity: 0.7; }
        .square.check { fill: #ff4444 !important; opacity: 0.8; }
        .square.last-move { fill: #bada55 !important; opacity: 0.4; }

        .piece { 
            cursor: grab; 
            transition: transform 0.2s ease; 
            pointer-events: all;
        }
        .piece.dragging { cursor: grabbing; opacity: 0.8; transform: scale(1.1); }
        .piece.not-turn { cursor: not-allowed; opacity: 0.6; }

        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 20px; flex-wrap: wrap; }
        button {
            padding: 10px 20px; 
            font-weight: bold; 
            border: none; 
            border-radius: 25px;
            cursor: pointer; 
            background: #764ba2; 
            color: white;
            transition: all 0.3s ease;
        }
        button:hover { background: #5a3680; transform: translateY(-2px); }
        button:active { transform: translateY(0); }

        .game-status { 
            text-align: center; 
            margin-top: 20px; 
            padding: 15px; 
            border-radius: 10px; 
            font-weight: bold;
            font-size: 1.2em;
            animation: fadeIn 0.5s ease;
        }
        .status-check { background: #fff3cd; color: #856404; border: 2px solid #ffc107; }
        .status-checkmate { background: #f8d7da; color: #721c24; border: 2px solid #dc3545; }
        .status-stalemate { background: #d1ecf1; color: #0c5460; border: 2px solid #17a2b8; }

        .promotion-modal {
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: rgba(0, 0, 0, 0.8); 
            z-index: 1000; 
            justify-content: center; 
            align-items: center;
        }
        .promotion-content { 
            background: white; 
            padding: 30px; 
            border-radius: 15px; 
            text-align: center;
            animation: scaleIn 0.3s ease;
        }
        .promotion-pieces { display: flex; gap: 20px; margin-top: 20px; }
        .promotion-piece { 
            cursor: pointer; 
            padding: 10px; 
            border-radius: 10px;
            transition: all 0.2s ease;
        }
        .promotion-piece:hover { 
            background: #f0f0f0; 
            transform: scale(1.1);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes scaleIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>

    <div class="p2p-panel">
        <div>Your ID: <span id="my-id" class="id-badge" title="Click to copy">...loading...</span></div>
        <input type="text" id="peer-id-input" placeholder="Paste Friend's ID">
        <button onclick="game.connectToPeer()">Connect to Friend</button>
        <div id="connection-status" style="color: #764ba2; font-weight: bold;">(Not Connected)</div>
    </div>

    <div class="game-container">
        <h1>♔ P2P Chess Game ♚</h1>
        
        <div class="game-info">
            <div class="turn-indicator white-turn" id="turnIndicator">White's Turn</div>
            <div class="captured-section">
                <div>White Captured:</div>
                <div class="captured-pieces" id="whiteCaptured"></div>
            </div>
            <div class="captured-section">
                <div>Black Captured:</div>
                <div class="captured-pieces" id="blackCaptured"></div>
            </div>
        </div>

        <div class="board-container">
            <svg id="chessboard" width="480" height="480" viewBox="0 0 480 480">
                <g id="squares"></g>
                <g id="pieces"></g>
            </svg>
        </div>

        <div class="controls">
            <button onclick="game.reset()">New Game</button>
            <button onclick="game.flipBoard()">Flip Board</button>
        </div>

        <div id="gameStatus" class="game-status" style="display: none;"></div>
    </div>

    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-content">
            <h2>Choose Promotion Piece</h2>
            <div class="promotion-pieces" id="promotionPieces"></div>
        </div>
    </div>

    <script>
        class ChessGame {
            constructor() {
                this.board = this.initializeBoard();
                this.currentTurn = 'white';
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.capturedPieces = { white: [], black: [] };
                this.moveHistory = [];
                this.boardFlipped = false;
                this.lastMove = null;
                this.enPassantTarget = null;
                this.castlingRights = {
                    white: { kingSide: true, queenSide: true },
                    black: { kingSide: true, queenSide: true }
                };
                this.isGameOver = false;
                
                // P2P Setup
                this.peer = new Peer();
                this.conn = null;
                this.myColor = null;

                this.setupPeerEvents();
                this.initializeSVG();
                this.renderBoard();
                this.renderPieces();
                this.attachEventListeners();
                this.setupIdCopy();
            }

            setupIdCopy() {
                document.getElementById('my-id').addEventListener('click', (e) => {
                    const text = e.target.innerText;
                    navigator.clipboard.writeText(text).then(() => {
                        const orig = e.target.innerText;
                        e.target.innerText = '✓ Copied!';
                        setTimeout(() => e.target.innerText = orig, 1500);
                    });
                });
            }

            setupPeerEvents() {
                this.peer.on('open', (id) => {
                    document.getElementById('my-id').innerText = id;
                });

                this.peer.on('connection', (connection) => {
                    this.conn = connection;
                    this.myColor = 'black';
                    document.getElementById('connection-status').innerText = "Playing as BLACK";
                    this.setupDataListener();
                });
            }

            connectToPeer() {
                const peerId = document.getElementById('peer-id-input').value.trim();
                if (!peerId) return alert("Please enter a Peer ID");
                
                this.conn = this.peer.connect(peerId);
                this.myColor = 'white';
                document.getElementById('connection-status').innerText = "Playing as WHITE";
                this.setupDataListener();
            }

            setupDataListener() {
                this.conn.on('data', (data) => {
                    if (data.type === 'move') {
                        this.executeMoveLogic(data.from.row, data.from.col, data.to.row, data.to.col, false, data.promotion);
                    }
                });
            }

            initializeBoard() {
                return [
                    ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null],
                    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                    ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
                ];
            }

            initializeSVG() {
                const squaresGroup = document.getElementById('squares');
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        square.setAttribute('x', col * 60);
                        square.setAttribute('y', row * 60);
                        square.setAttribute('width', 60);
                        square.setAttribute('height', 60);
                        square.setAttribute('class', `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`);
                        square.setAttribute('data-row', row);
                        square.setAttribute('data-col', col);
                        squaresGroup.appendChild(square);
                    }
                }
            }

            renderBoard() {
                document.querySelectorAll('.square').forEach(sq => 
                    sq.classList.remove('highlight', 'possible-move', 'selected', 'last-move')
                );
                
                if (this.lastMove) {
                    const fromSq = document.querySelector(`[data-row="${this.lastMove.from.row}"][data-col="${this.lastMove.from.col}"]`);
                    const toSq = document.querySelector(`[data-row="${this.lastMove.to.row}"][data-col="${this.lastMove.to.col}"]`);
                    if (fromSq) fromSq.classList.add('last-move');
                    if (toSq) toSq.classList.add('last-move');
                }

                if (this.selectedSquare) {
                    const sel = document.querySelector(`[data-row="${this.selectedSquare.row}"][data-col="${this.selectedSquare.col}"]`);
                    if (sel) sel.classList.add('selected');
                    this.possibleMoves.forEach(m => {
                        const moveEl = document.querySelector(`[data-row="${m.row}"][data-col="${m.col}"]`);
                        if (moveEl) moveEl.classList.add('possible-move');
                    });
                }

                this.highlightCheck();
            }

            highlightCheck() {
                document.querySelectorAll('.square').forEach(sq => sq.classList.remove('check'));
                const kingPos = this.findKing(this.currentTurn);
                if (kingPos && this.isSquareUnderAttack(kingPos.row, kingPos.col, this.currentTurn)) {
                    const kingSq = document.querySelector(`[data-row="${kingPos.row}"][data-col="${kingPos.col}"]`);
                    if (kingSq) kingSq.classList.add('check');
                }
            }

            renderPieces() {
                const piecesGroup = document.getElementById('pieces');
                piecesGroup.innerHTML = '';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) piecesGroup.appendChild(this.createPieceSVG(piece, col * 60, row * 60));
                    }
                }
            }

            createPieceSVG(piece, x, y) {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'piece');
                g.setAttribute('data-piece', piece);
                g.setAttribute('data-x', x);
                g.setAttribute('data-y', y);
                g.setAttribute('transform', `translate(${x + 30}, ${y + 30})`);
                
                const color = piece === piece.toUpperCase() ? 'white' : 'black';
                const isMyPiece = !this.conn || this.getPieceColor(piece) === this.myColor;
                if (!isMyPiece || this.currentTurn !== this.getPieceColor(piece)) {
                    g.classList.add('not-turn');
                }
                
                const symbols = { 'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚' };
                g.innerHTML = `
                    <circle cx="0" cy="0" r="25" fill="${color === 'white' ? '#fff' : '#333'}" stroke="#999" stroke-width="2"/>
                    <text x="0" y="10" text-anchor="middle" font-size="30" fill="${color === 'white' ? '#000' : '#fff'}">${symbols[piece.toLowerCase()]}</text>
                `;
                return g;
            }

            attachEventListeners() {
                const svg = document.getElementById('chessboard');
                svg.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                svg.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                svg.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                svg.addEventListener('click', (e) => this.handleClick(e));
            }

            handleClick(e) {
                if (this.isGameOver) return;
                if (this.conn && this.currentTurn !== this.myColor) return;

                const square = e.target.closest('.square');
                if (!square) return;

                const row = parseInt(square.getAttribute('data-row'));
                const col = parseInt(square.getAttribute('data-col'));

                if (this.selectedSquare) {
                    this.makeMove(row, col);
                } else {
                    const piece = this.board[row][col];
                    if (piece && this.isCorrectTurn(piece)) {
                        this.selectPiece(row, col);
                    }
                }
            }

            handleMouseDown(e) {
                if (this.isGameOver) return;
                if (this.conn && this.currentTurn !== this.myColor) return;

                const target = e.target.closest('.piece');
                if (!target) return;
                
                const x = parseInt(target.getAttribute('data-x'));
                const y = parseInt(target.getAttribute('data-y'));
                const col = Math.floor(x / 60);
                const row = Math.floor(y / 60);
                
                const piece = this.board[row][col];
                if (this.isCorrectTurn(piece)) {
                    this.isDragging = true;
                    this.dragPiece = target;
                    this.dragStartPos = { row, col };
                    const svg = document.getElementById('chessboard');
                    const rect = svg.getBoundingClientRect();
                    this.dragOffset = { 
                        x: e.clientX - rect.left - x - 30, 
                        y: e.clientY - rect.top - y - 30 
                    };
                    target.classList.add('dragging');
                    this.selectPiece(row, col);
                }
            }

            handleMouseMove(e) {
                if (!this.isDragging) return;
                const svg = document.getElementById('chessboard');
                const rect = svg.getBoundingClientRect();
                const x = e.clientX - rect.left - this.dragOffset.x;
                const y = e.clientY - rect.top - this.dragOffset.y;
                this.dragPiece.style.transform = `translate(${x}px, ${y}px)`;
            }

            handleMouseUp(e) {
                if (!this.isDragging) return;
                const svg = document.getElementById('chessboard');
                const rect = svg.getBoundingClientRect();
                const col = Math.floor((e.clientX - rect.left) / 60);
                const row = Math.floor((e.clientY - rect.top) / 60);

                if (this.isInBounds(row, col)) {
                    this.makeMove(row, col);
                }

                this.dragPiece.classList.remove('dragging');
                this.dragPiece.style.transform = '';
                this.isDragging = false;
                this.dragPiece = null;
            }

            getPieceColor(piece) {
                return piece === piece.toUpperCase() ? 'white' : 'black';
            }

            isCorrectTurn(piece) {
                if (!piece) return false;
                return this.getPieceColor(piece) === this.currentTurn;
            }

            selectPiece(row, col) {
                this.selectedSquare = { row, col };
                this.possibleMoves = this.getLegalMoves(row, col);
                this.renderBoard();
            }

            getLegalMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];

                const moves = this.getPossibleMoves(row, col, piece);
                return moves.filter(move => {
                    return !this.wouldBeInCheck(row, col, move.row, move.col);
                });
            }

            getPossibleMoves(row, col, piece) {
                const type = piece.toLowerCase();
                const color = this.getPieceColor(piece);
                const moves = [];

                switch (type) {
                    case 'p':
                        moves.push(...this.getPawnMoves(row, col, color));
                        break;
                    case 'r':
                        moves.push(...this.getRookMoves(row, col, color));
                        break;
                    case 'n':
                        moves.push(...this.getKnightMoves(row, col, color));
                        break;
                    case 'b':
                        moves.push(...this.getBishopMoves(row, col, color));
                        break;
                    case 'q':
                        moves.push(...this.getQueenMoves(row, col, color));
                        break;
                    case 'k':
                        moves.push(...this.getKingMoves(row, col, color));
                        break;
                }

                return moves;
            }

            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;

                // Forward move
                const newRow = row + direction;
                if (this.isInBounds(newRow, col) && !this.board[newRow][col]) {
                    moves.push({ row: newRow, col });

                    // Double move from start
                    if (row === startRow) {
                        const doubleRow = row + 2 * direction;
                        if (!this.board[doubleRow][col]) {
                            moves.push({ row: doubleRow, col });
                        }
                    }
                }

                // Captures
                [-1, 1].forEach(dc => {
                    const newCol = col + dc;
                    if (this.isInBounds(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target && this.getPieceColor(target) !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        // En passant
                        if (this.enPassantTarget && 
                            this.enPassantTarget.row === newRow && 
                            this.enPassantTarget.col === newCol) {
                            moves.push({ row: newRow, col: newCol, isEnPassant: true });
                        }
                    }
                });

                return moves;
            }

            getRookMoves(row, col, color) {
                return this.getLinearMoves(row, col, color, [
                    [-1, 0], [1, 0], [0, -1], [0, 1]
                ]);
            }

            getBishopMoves(row, col, color) {
                return this.getLinearMoves(row, col, color, [
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ]);
            }

            getQueenMoves(row, col, color) {
                return this.getLinearMoves(row, col, color, [
                    [-1, 0], [1, 0], [0, -1], [0, 1],
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ]);
            }

            getLinearMoves(row, col, color, directions) {
                const moves = [];
                directions.forEach(([dr, dc]) => {
                    let r = row + dr, c = col + dc;
                    while (this.isInBounds(r, c)) {
                        const target = this.board[r][c];
                        if (!target) {
                            moves.push({ row: r, col: c });
                        } else {
                            if (this.getPieceColor(target) !== color) {
                                moves.push({ row: r, col: c });
                            }
                            break;
                        }
                        r += dr;
                        c += dc;
                    }
                });
                return moves;
            }

            getKnightMoves(row, col, color) {
                const moves = [];
                const offsets = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                offsets.forEach(([dr, dc]) => {
                    const r = row + dr, c = col + dc;
                    if (this.isInBounds(r, c)) {
                        const target = this.board[r][c];
                        if (!target || this.getPieceColor(target) !== color) {
                            moves.push({ row: r, col: c });
                        }
                    }
                });
                return moves;
            }

            getKingMoves(row, col, color) {
                const moves = [];
                const offsets = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1], [0, 1],
                    [1, -1], [1, 0], [1, 1]
                ];
                offsets.forEach(([dr, dc]) => {
                    const r = row + dr, c = col + dc;
                    if (this.isInBounds(r, c)) {
                        const target = this.board[r][c];
                        if (!target || this.getPieceColor(target) !== color) {
                            moves.push({ row: r, col: c });
                        }
                    }
                });

                // Castling
                if (this.castlingRights[color].kingSide && this.canCastle(color, true)) {
                    moves.push({ row, col: col + 2, isCastling: true, isKingSide: true });
                }
                if (this.castlingRights[color].queenSide && this.canCastle(color, false)) {
                    moves.push({ row, col: col - 2, isCastling: true, isKingSide: false });
                }

                return moves;
            }

            canCastle(color, isKingSide) {
                const row = color === 'white' ? 7 : 0;
                const kingCol = 4;
                const rookCol = isKingSide ? 7 : 0;
                const direction = isKingSide ? 1 : -1;

                // Check if squares between king and rook are empty
                const start = isKingSide ? kingCol + 1 : rookCol + 1;
                const end = isKingSide ? rookCol : kingCol;
                for (let c = start; c < end; c++) {
                    if (this.board[row][c]) return false;
                }

                // Check if king passes through or ends in check
                for (let c = kingCol; c !== kingCol + 2 * direction + direction; c += direction) {
                    if (this.isSquareUnderAttack(row, c, color)) return false;
                }

                return true;
            }

            wouldBeInCheck(fromRow, fromCol, toRow, toCol) {
                // Simulate move
                const originalPiece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                
                this.board[toRow][toCol] = originalPiece;
                this.board[fromRow][fromCol] = null;

                const kingPos = this.findKing(this.currentTurn);
                const inCheck = kingPos && this.isSquareUnderAttack(kingPos.row, kingPos.col, this.currentTurn);

                // Undo move
                this.board[fromRow][fromCol] = originalPiece;
                this.board[toRow][toCol] = capturedPiece;

                return inCheck;
            }

            isSquareUnderAttack(row, col, byColor) {
                const opponentColor = byColor === 'white' ? 'black' : 'white';
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && this.getPieceColor(piece) === opponentColor) {
                            const moves = this.getPossibleMoves(r, c, piece);
                            if (moves.some(m => m.row === row && m.col === col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            findKing(color) {
                const kingPiece = color === 'white' ? 'K' : 'k';
                for (let r = 0; r < 8; r
